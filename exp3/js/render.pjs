var hitOptions = {
	segments: true,
	stroke: false,
	fill: true,
	tolerance: 5
};
var conPosition = [
	[0, 48],
	[48, 0],
	[-48, 0],
	[0, -48]
]
var LIUBEI = "刘备";
var ZHANGFEI = "张飞";
var ZHAOYUN = "赵云";
var GUANYU = "关羽";
var ZHUGELIANG = "诸葛亮";

var segment, item, connection, endPoint;
connections = {}
var movePath = false;
var connId;
var previousGroup;
var avatars_url = ['imgs/liubei.jpg','imgs/zhangfei.jpg','imgs/zhaoyun.jpg','imgs/guanyu.jpg','imgs/zhugeliang.jpg']
var avatars_name = [LIUBEI,ZHANGFEI,ZHAOYUN,GUANYU,ZHUGELIANG];

DAG = new Array(new Array(),new Array());

function Connector(point, item) {
	this.group = new Group()
	this.group.name = 'connector';
	// Container
	this.container = new Path.Rectangle({
		point: [0, 0],
		size: [100, 100],
		radius: 20,
		fillColor: 'grey',
		position: point,
		opacity: 0,
		name: 'backgroud'
	})
	this.group.addChild(this.container)
	this.connectGroup = new Group({name: 'connectpoints'})

	// connect points
	for (var i = 0; i < conPosition.length; i++) {
		this.connectGroup.addChild(
			new Path.Circle({
				center: new Point(conPosition[i]) + point,
				radius: 3,
				strokeColor: 'blue',
				name: 'connectpoint',
				visible: false
			})
		)
	}
	this.group.addChild(this.connectGroup)
	// add content
	if(item){
		item.fitBounds(new Rectangle({
			point:point - [40,40],
			size:[80,80]
		}))
		this.group.addChild(item)
		item.sendToBack()
	}
		
}

function onMouseDown(event) {
	segment = item = connId = null;
	var hitResult = project.hitTest(event.point, hitOptions);
	if (!hitResult)
		return;
	if (hitResult) {
		//console.log(hitResult.type)
		if (hitResult.type == 'segment') {
			segment = hitResult.segment;
			if (segment.path.name != 'connectpoint') return
			connId = segment.path.parent.parent.children['backgroud'].id
			connection = new Path();
			connection.sendToBack();
			connection.strokeColor = 'red'
			startPoint = segment.path.position
			connection.add(startPoint);
			endPoint = new Point(event.point);
			connection.add(endPoint);
			if (!(connId in connections)) connections[connId] = []
			connections[connId].push(connection.firstSegment)
		}
		if (hitResult.type == 'fill') {
			item = hitResult.item;
			connId = item.id
		}
	}
}



function onMouseMove(event) {
	if (event.item && event.item.name == 'connector') {
		showConnectpoint(event.item)
		previousGroup = event.item;
	} else {
		if (previousGroup)
			hideConnectpoint(previousGroup)
	}
}

function onMouseDrag(event) {
	var hitResult = project.hitTest(event.point, hitOptions);
	if (hitResult) {
		if (hitResult.type == 'fill') {
			group = hitResult.item.parent;
			if (previousGroup)
				hideConnectpoint(previousGroup)
			showConnectpoint(group)
			previousGroup = group
		}
	}
	if (segment && segment.path.name == 'connectpoint') {
		connection.lastSegment.point += event.delta;
	} else if (item && item.parent.name == 'connector') {
		item.parent.position += event.delta;
		// Move the connect points.
		if (connId in connections)
			for (var i in connections[connId]) {
				connections[connId][i].point += event.delta;
			}
	}
}

function onMouseUp(event) {
	var hitResult = project.hitTest(event.point, hitOptions);
	if (!hitResult) {
		//return;
	}
	else{
		console.log(hitResult.type)
		if (hitResult.type == 'segment') {
			segment = hitResult.segment;
			console.log(segment.path.name)
			if (segment.path.name == 'connectpoint') {
				connection.lastSegment = segment.path.position
				newconnId = segment.path.parent.parent.children['backgroud'].id
				if(connId !=newconnId){
					line = new Path.Line({
						from:connection.firstSegment.point,
						to:connection.lastSegment.point,
						strokeColor:'black',
						strokeWidth: 2
						})
					line.sendToBack()
					connections[connId].push(line.firstSegment)
					if (!(newconnId in connections)) connections[newconnId] = []
					connections[newconnId].push(line.lastSegment)
					addEdge(connId, newconnId)
				}

				//connection = null
			}
		}
	}
	if (connection)
		connection.remove();
}

function showConnectpoint(group) {
	for (i = 0; i < 4; i++) {
		group.children['connectpoints'].children[i].visible = true;
	}
	group.children['backgroud'].opacity = 0.5;
}

function hideConnectpoint(group) {
	for (i = 0; i < 4; i++) {
		group.children['connectpoints'].children[i].visible = false;
	}
	group.children['backgroud'].opacity = 0;
}
function addEdge(point1, point2){
	point1<=point2?DAG[point1] = point2:DAG[point2] = point1
}

initStep2 = function (id){
	onResize()
	console.log(view.center)
	var temp = new Raster({
		source: 'imgs/crown.png',
	})
	temp.fitBounds(new Rectangle({
			point:pos_crwon[id],
			size:[30,30]
		}))
	temp.rotate(30)
	showLegend()
	view.draw()
}
setStep2 = function(from, to, ready){
	if(from!=to)
		edges[from][to].strokeColor = ready?"green":"red"
	else{
		avatars[from].fillColor = ready?"green":"red"
	}
	view.draw()
}
resetStep2 = function(){
	for(var i=0;i<5;i++){
		for (var j=0; j<5; j++) {
			if(i!=j)
			edges[i][j].strokeColor = 'grey';
		};
		avatars[i].fillColor = 'grey';
	}
	view.draw()
}
showLegend = function(){
	var temp = new Raster({
		source: 'imgs/crown.png',
	})
	temp.fitBounds(new Rectangle({
			point:[20,10],
			size:[30,30]
		}))
	new PointText({
		position:[80,30],
 		fillColor : 'black',
 		content : '您控制的角色'
 	})
	new Path.Line({
		from: [20,50],
		to:[50,50],
		strokeColor:'grey',
		strokeWidth: 2
	}).lineBy(
	    new Point({
	        angle: 160,
	        length:10
	    })
	)
	new PointText({
		position:[80,50],
 		fillColor : 'black',
 		content : '信鸽可通过的路径'
 	})

	new Path.Line({
		from: [20,70],
		to:[50,70],
		strokeColor:'green',
		strokeWidth: 2
	}).lineBy(
	    new Point({
	        angle: 160,
	        length:10
	    })
	)
	new PointText({
		position:[80,70],
 		fillColor : 'black',
 		content : '起点玩家声称终点玩家为就绪状态'
 	})

	new Path.Line({
		from: [20,90],
		to:[50,90],
		strokeColor:'red',
		strokeWidth: 2
	}).lineBy(
	    new Point({
	        angle: 160,
	        length:10
	    })
	)
	new PointText({
		position:[80,90],
 		fillColor : 'black',
 		content : '起点玩家声称终点玩家为整备状态'
 	})

}

onResize = function() {
	view.viewSize.width = view.element.clientWidth;
	view.viewSize.height = view.element.clientHeight;
}

refreshCanvas =function(){
	view.draw()
}

// var raster = new Raster({
//     source: 'imgs/liubei.jpg',
// });
// var raster2 = new Raster({
//     source: 'imgs/zhaoyun.jpg',
// });
// var raster3 = new Raster({
//     source: 'imgs/zhangfei.jpg',
// });
// var army =  new Group();
// army.addChild(new PointText({
// 	fillColor : 'black',
// 	content : '士兵'
// 	}))

// var food =  new Group();
// food.addChild(new PointText({
// 	fillColor : 'black',
// 	content : '粮食'
// 	}))
// var weather =  new Group();
// weather.addChild(new PointText({
// 	fillColor : 'black',
// 	content : '天气'
// 	}))

// objects = []
// objects.push(new Connector(new Point(50, 50), raster))
// objects.push(new Connector(new Point(300, 100), raster2))
// objects.push(new Connector(new Point(200, 50), raster3))
// objects.push(new Connector(new Point(300, 200), army))
// objects.push(new Connector(new Point(400, 300), food))
// objects.push(new Connector(new Point(500, 200), weather))

onResize()
var createArray2D = function(m,n){
	array = {}
	for(var x=0;x<m;x++){
		array[x] = {}
		for(var y=0;y<n;y++){
			array[x][y] = null;
		}
	}
	return array
}

edges = createArray2D(5,5)
pos_crwon = {}
avatars = {}
poly5in = new Path.RegularPolygon(view.center,5,170)
poly5in.segments[0].point
for(var i=0;i<5;i++){
	for(var j=0;j<5;j++){
		if(i!=j){
			var vector = (poly5in.segments[j].point - poly5in.segments[i].point).normalize(1)
			var vert_vector = vector.rotate(90)*3
			var line = new Path.Line({
				from:poly5in.segments[i].point + vert_vector + vector*20,
				to:poly5in.segments[j].point + vert_vector - vector*20,
				strokeColor:'grey',
				strokeWidth: 2
			})
			line.lineBy(
			    new Point({
			        angle:vector.getAngle()+160,
			        length:20
			    })
			)
			edges[i][j] = line;
		}
	}
}
poly5out = new Path.RegularPolygon(view.center,5,200)
for(var i=0;i<5;i++){
	s = poly5out.segments[i].point
	var r = new Raster({
    source: avatars_url[i],
    position: s
	});
	r.scale(0.5)
	pos_crwon[i] = new Point(r.bounds.x + r.bounds.width-10, r.bounds.y-20)
	avatars[i] = new Path.Rectangle({
		position: s,
		size: [r.bounds.width+10,r.bounds.height+10],
		radius: 20,
		fillColor: 'grey'
	})
	avatars[i].sendToBack();
}


